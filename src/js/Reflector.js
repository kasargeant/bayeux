"use strict";

// Imports
const child = require("child_process");

const myObj = {
    a: "some property",
    printA: function() {
        console.log(this.a);
    },
    printOther: function(text) {
        console.log(text);
    }
};

function extractDefinition(targetPath) {
    let stdout = child.execSync(`jsdoc ${targetPath} -t templates/haruki -d console -q format=json`);
    return stdout;
}

// function extractParameters(fnStr) {
//     let begin = fnStr.indexOf("(") + 1;
//     let end = fnStr.indexOf(")");
//     let params = fnStr.slice(begin, end);
//     return params.split(", ");
// }
function extractSignature(fnStr) {
    let begin = fnStr.indexOf("(");
    let end = fnStr.indexOf(")");
    let stem = fnStr.slice(0, begin);
    stem = stem.replace("function ", "");
    if(stem === "") {stem = "ANON";}
    let params = fnStr.slice(begin + 1, end);
    if(params === "") {
        params = [];
    } else {
        params = params.split(", ");
    }
    return [stem, ...params];
}

function reflect(value) {
    let reflections = {};
    switch(typeof value) {
        case "object":
            let obj = value;
            let objKeys = Object.keys(obj);
            console.log("Keys: " + objKeys);

            for(let objKey of objKeys) {
                //console.log(objKey);
                let objValue = obj[objKey];
                if(typeof objValue === "function") {
                    let source = objValue.toString();//_stringifyFunction(objValue);
                    //console.log(source);
                    let signature = extractSignature(source);
                    let parameters = signature.slice(1);
                    // console.log(`Signature: ${JSON.stringify(signature)}`);
                    // console.log(`Parameters: ${JSON.stringify(parameters)}`);
                    reflections[objKey] =  parameters;
                }
            }
            break;
        case "function":
            let source = value.toString();//_stringifyFunction(value);
            //console.log(source);
            let signature = extractSignature(source);
            let name = signature[0];
            let parameters = signature.slice(1);
            // console.log(`Signature: ${JSON.stringify(signature)}`);
            // console.log(`Parameters: ${JSON.stringify(parameters)}`);
            reflections[name] =  parameters;
            break;
        default:
            console.error("Error: Unrecognised value type.");
    }
    return reflections;
}

function templateTest(actualFnCall, expectedValue=true, msg="This autogenerated description must be replaced.") {
    return `
    test("something like a class", function(done) {
        
        is.equal(${actualFnCall}, ${expectedValue}, "${msg}");
        is.notEqual(${actualFnCall}, ${!expectedValue}, "${msg}");

        done(); // Indicate the test has finished
    });
`;
}
function templateUnit(filename, testCases, msg) {
    return `
"use strict";

// Imports
const {is, unit, test} = require("../../../src/js/Bayeux");

// Unit(s)
// const Square = require("../../../src/js/Square");

// Unit test(s)
unit(${msg}, function() {

    ${testCases}

});
`;
}

function generateTestScript(descObj) {

    let reflection = reflect(descObj);
    console.log(JSON.stringify(reflection));
    let tests = "";

    for(let key in reflection) {
        // console.log("KEY: " + key);
        let params = reflection[key];
        let call = `${key}(${params.toString()})`;
        let test = templateTest(call, undefined, "it should validate the parameters.");
        tests += test + "\n";
    }
    let testUnit = templateUnit("somefile.js", tests, "Autogenrated test cases.");

    //console.log(testUnit);
    return testUnit;
}

// const {is, unit, test} = require("./Bayeux");
// let testScript = generateTestScript(is);

// Exports
module.exports = generateTestScript;

//
//
// let out = extractDefinition("../scratch/Pageant.js");
// console.log(out.toString());